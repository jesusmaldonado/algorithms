Algorithms solution


2.1
1. Insertion sort diagram

A = [31,41,59,26,41,58]
no sorts until the third element
A = [26,31,41,59,41,58]
A = [26,31,41,41,59,58]
A = [26,31,41,41,58,59]

This is a mixed-case scenario where insertion sort is actually not ~that~ bad. Between O(n) and O(n^2)

2. Just flip the comparator.

def inc_insertion_sort(array)
  #go through the array
  array.each_with_index do |el, i| #n steps
    #the elements starting from [0..i - 1] will always be sorted (initialization loop invariant)
    # run 1: el: 5, i: 1
    j = i - 1 #1 step
    while j >= 0 && array[j] < el #at worst, we will do n-1 comparisons
      # run 1: true
      array[j+1] = array[j]
      # run1: [5,5,4,6,1,3]
      j -= 1
      # run1: 0
    end
    array[j+1] = el #1 step
    # run1: [2,5,4,6,1,3]
    #the array is still sorted (propagation)
  end
  array #1 step (then here at termination, the algorithm is correct)
end

3. Write linear search, and use the loop invariant induction to prove your algorithm is correct.
  def linear_search(array, v)
    array.each do |item|
      #loop invariant: initialization (item v does exist)
      #propagation (if item != v) propagates the loop, yielding more items (propagation)
      return v if item == v
      #termination, two conditions (if item == v), we return from the method, avoiding the nil
    end
    #if the item does not exist in the array, then we return nil
    nil
  end
  #O(n) runtime, possibly O(1) memory, at most O(2) not sure if storing V counts as an object?

4. Input: two (n-bit arrays are inserted, with length of n elements) are to be added.

    Output: a new n+1 array with the output of the addition:

2.2
Algorithm analysis usually happens in terms of the input size, which for numbers is n or for graphs (vertex, edge) notation is usually sufficient.

2.3
Express n^3/1000 - 100n^2 - 100n + 3 in O(n) - > O(n^3)

2.4
Selection Sort.
